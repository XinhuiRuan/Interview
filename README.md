# Vue
Q1: v-show 与 v-if 区别

1.相同点：v-show和v-if都能控制元素的显示和隐藏。

2.不同点：

实现本质方法不同：
v-show本质就是通过设置css中的display设置为none，控制隐藏；
v-if是动态的向DOM树内添加或者删除DOM元素。

编译的区别：
v-show其实就是在控制css；
v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件。

编译的条件：
v-show都会编译，初始值为false，只是将display设为none，但它也编译了；
v-if初始值为false，就不会编译了。

性能：
v-show只编译一次，后面其实就是控制css，而v-if不停的销毁和创建，故v-show性能更好一点。

注意点：因为v-show实际是操作display:" "或者none，当css本身有display：none时，v-show无法让显示。

总结：
如果要频繁切换某节点时，使用v-show（无论true或者false初始都会进行渲染，此后通过css来控制显示隐藏，因此切换开销比较小，初始开销较大）；
如果不需要频繁切换某节点时，使用v-if（因为懒加载，初始为false时，不会渲染，但是因为它是通过添加和删除dom元素来控制显示和隐藏的，因此初始渲染开销较小，切换开销比较大）。

参考：https://www.cnblogs.com/liutianzeng/p/10978890.html


Q2: methods(方法)、computed(计算属性)、watch(侦听器)的区别

1、computed和methods

共同点：computed能现实的methods也能实现；

不同点：computed是基于它的依赖进行缓存的。computed只有在它的相关依赖发生变化才会重新计算求值。 而只要它的相关依赖没有发生变化，多次访问会立即返回之前的计算结果，而不必再次执行计算。相比之下，每当触发重新渲染时，调用方法将总会再次执行函数。也就是说当我们不希望有缓存，用方法来替代。（关于缓存和重新渲染，看详解：https://www.jb51.net/article/138743.htm）

2、watch和computed

共同点：以 Vue 的依赖追踪机制为基础，当某个依赖数据发生变化时，所有依赖这个数据的相关数据或函数都会自动发生变化或调用；

不同点：computed是自动监听依赖值的变化，从而动态返回内容；watch是一个过程，在监听的值变化时，可以触发一个回调，并做一些事情。所以区别来源于用法，只是需要动态值，那就用计算属性；需要知道值的改变后执行业务逻辑，才用 watch，用反或混用虽然可行，但都是不正确的用法。
使用 watch 选项允许我们执行异步操作（访问一个 API）或高消耗性能的操作，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态，而这些都是计算属性无法做到的。

另外总结了几点关于 computed 和 watch 的差异：

  1. computed 是计算一个新的属性，并将该属性挂载到 vm（Vue 实例）上，而 watch 是监听已经存在且已挂载到 vm 上的数据，所以用 watch 同样可以监听  
      computed 计算属性的变化（其它还有 data、props）;

  2. computed 本质是一个惰性求值的观察者，具有缓存性，只有当依赖变化后，第一次访问 computed 属性，才会计算新的值，而 watch 则是当数据发生变化便会调
      用执行函数;
      
  3. 从使用场景上说，computed 适用一个数据被多个数据影响，而 watch 适用一个数据影响多个数据；
  
  参考：https://segmentfault.com/a/1190000016387717

Q2扩展问题：

Q2-1： computed 是一个对象时，它有哪些选项？

有 get 和 set 两个选项。

get是当该对象所依赖的变量发生变化是执行，重新return computed结果。

set是该对象的值变化时会执行，并且将变化的结果作为参数传进set里，然后可以根据传进的值来处理。

Q2-2：computed 是否能依赖其它组件的数据？

computed 可以依赖其它 computed，甚至是其它组件的 data。

Q2-3：watch 是一个对象时，它有哪些选项？




